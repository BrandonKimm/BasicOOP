객체지향프로그래밍의 개념
Objective Oriented Programming

OOP의 깊이있는 내용은 아니고 개념을 간략히 받아들이는 정도로 생각하자!

1. 자바 객체지향프로그래밍 선행지식
    1) 객체와 클래스의 명확한 구분
        사람은 객체인가? 클래스인가?
        김원빈은 객체인가? 클래스인가?
        카페는 객체인가? 클래스인가?
        이디야독산점은  객체인가? 클래스인가?
        ==> 사람은 몇살인가? 김원빈은 몇살인가?
        ==> 카페는 몇년도에 오픈했지? 이디야독산점은 몇년도에 오픈했지?

        클래스는 분류 / 객체는 실체
        김원빈은 실체이기떄문에 28살 객체 / 사람은 분류이기때문에 몇살인지는 잘 모르겠다!
        붕어빵틀은 클래스 붕어빵은 객체다! 그런 맹신은 그만하자!
        (물론 객체(Object) = 클래스들의 인스턴스 느낌으로는 일부 맞는 말)
        * 클래스멤버 : 객체멤버 = 스태틱멤버 : 인스턴스멤버 = 정적멤버 : 동적멤버

        1-1) 변수유형
          이름          / 다른이름                     / 할당메모리
          staic 변수    / 클래스멤버변수, 정적변수, 정적속성 / 스태틱영역
          instance 변수 / 객체멤버변수, 객체변수          / 힙 영역
          local 변수    / 지역변수                     / 스택영역(스택프레임내부)
          * 스태틱멤버들은 초기화 안해줘도 0 / 0.0 / null / false 초기화되어있고 지역변수들은 쓰레기값
          * final static 인데 초기화 안되어있으면 컴파일조차 안되는 그런 같은 맥락
          * static 메소드 안에서 static 변수만 사용할 수 있는건 맞는데
            ==> static메소드안이라고해서 static변수를 새로 선언할 순 없더라 컴파일에러나더라 클래스영역에는 클래스정보 메소드이름 정보까지만 만들어는건가 ㅎㅎ;;

    2) 추상화 모델링
        애플리케이션의 컨텍스트(경계)에 따라 클래스(분류)를 모델링한다는 느낌
        그러다가 공통적인건 클래스멤버로 빼고 인스턴스멤버로 넣을 거 넣고 그런 모델링 과정
        상속을 통한 추상화와 구체화, 인터페이스를 통한 추상화, 다형성을 통한 추상화 결국 캡상추다는 전부 interactional relation

    3) 상속
        상속이라는건 재사용과 확장이라는 개념을 받아들여야된다. (inheritance 버리고 extends 받아들이기)
        상속 = 재사용 + 확장  ==> 부모클래스/자식클래스(X) : 상위클래스/하위클래스(O) 또는 슈퍼클래스/서브클래스(O)
        조직도/계층도처럼 할아버지 아버지 할머니 어머니 처럼 그만 이해하고
        동물이라는 상위클래스에 하위클래스로 포유류와 조류가 있고 포유류의 하위클래스로 고래와 박쥐 그리고 조류의 하위클래스로 참새와 팽귄이 있다는 포함관계로 받아들이기
        * 하위클래스는 상위클래스다 ==>  아버지는 할아버지다(X) / 포유류는 동물이다(O)

        <Subclass is a SuperClass> : <남자 is a 사람 > : <하위클래스 is a 상위클래스>
        틀린건 아니다 맞긴 맞는데 < 김원빈 is a 사람 > : <인스턴스 is a 클래스 > 이렇게 받아들일 수 도 있으니까
        깔끔하게 <Subclass is a kind of SuperClass> : <남자 is kind of 사람> 아주 개운하군 == 남자는 사람의 한 분류다.

        -객체지향의 상속은 상위클래스의 특성을 재사용하는 것이다. (overriding)
        -객체지향의 상속은 상위클래스의 특성을 확장하는 것이다.   (extends)
        -객체지향의 상속은 is a kind of 관계를 만족해야 한다. (classify)

        -객체지향의 인터페이스는 be able to (Serializable, Cloneable, Comparable...)
         * 나중에 SOLID 에서 다시보자! ( LSP / ISP ) ==> 상위클래스의 특성은 최대한 다양하게 / 인터페이스는 구현을 강제할 메서드의 개수는 최대한 작게

        ==> 상속에서 하위클래스가 생성될 때 상위클래스도 힙에 같이 할당되는 내용과 상위클래스타입으로 하위클래스를 생성했을 때 묵시적형변환이 일어나는 과정들
            인터페이스가 왜 필요한지 알게 되는 이 맥락들 정확하게 인지하기!
            /* 객체 instanceof 분류  : instance instanceof class*
    4) 다형성
        상속에 다형성 내용이 엄청 많이 포함 돼 있다 상위클래스타입으로 하위클래스 타입을 선언해서 사용할 수 있다던가 형변환생기는이슈가 있다던가
        하위클래스의 메소드 중 오버라이딩 된 메소드에 대한 특징이라던가 상속이랑 다형성은 관계가 너무 깊어서 묶어서 설명하는게 맞겠다
        오버로딩! 이건 상속이랑 상관없는 유일한 다형성의 예시겠네 같은 메소드이름으로 중복정의 하는 내용 기억하기

    5) 캡슐화
        접근제한자 private / public / default(같은패키지 내)/ protected ==> 서브클래스가 아니더라도 같은 패키지면 접근가능하다!
        정적멤버(static class 변수)는 김원빈.다리갯수(x) 사람.다리갯수(O) 형식으로 접근하자! 일관성 및 성능을 위해 (사람.다리갯수, 다리갯수, this.다리갯수 )
        추상화랑 캡슐화를 좀 가볍게 다뤘는데 조금씩 보태기~

2. 자바의 객체지향특징
    1) 추상클래스
        다형성을 위한 특정슈퍼클래스타입의 변수들을 일괄적으로 처리하고싶은데 서브클래스 중 오버라이딩 안된 클래스가 있으면 컴파일에러나버리니까
        추상클래스 추상메소드로 개념을 만들었고 추상메소드 내에 내용이 없기때문에 추상클래스의 인스턴스는 생성할 수 없게 금지한게 추상클래스
    2) 생성자
        반환값이 없고 클래스명과 같은 이름을 가진 메서드를 객체를 생성하는 메서드라해서 "객체 생성자 메소드" 곧 "생성자"
        특이점은 인자값존재하는 생성자를 직접 커스텀했다면 디폴트생성자도 직접 생성해줘야 된다는점 정도?
    3) static block
        클래스생성자같은 느낌? 클래스정보는 클래스가 코드에서 처음 딱 사용 될 때 스태틱영역에 로딩되고 그떄 딱 한번 클래스의 static블록이 실행.
        클래스가 처음 코드에서 사용된다는건 정적속성/정적메소드/인스턴스최초생성 일떄
    4) final
        public final class 김원빈 { ... } ==> 상속을 허용하지 않음
        final static int 정적속성(정적상수) = 1 / fianl int 객체상수 = 1 ==> 변경불가능한 상수로 되게끔
        final void 밥먹다() { ... } ==> override 허용하지않음
    5) instance of 연산자
        객체참조변수 instanceof 클래스명
        특이점은 LSP(리스코프치환원칙)어기는 단골손님이라는거? 객체참조변수의 타입이아니고 실제객체타입로 처리하기 때문에
    6) package
        같은 클래스이름이더라도 패키지를 다르게해서 각각 사용하게끔 클래스의 소유자 ==> 패키지
    7) interface
        인터페이스 내에 있는 멤버변수 언제나 public static final / public abstract 생략돼있다는점
        그리고 1.8부터는 디폴트메소드라는 객체구상메소드와 정적추상메소드를 지원한다는 점 그리고 추클과 마찬가지 객체 생성할 수 없다는거
    8) this
        이게 참 사실 심오한데 간략한 느낌은 객체변수와 지역변수를 구분하는 역할
        클래스 내에 객체변수에도 int val = 10 있고 특정메소드 내에 지역변수 int val =20 있을때
        메소드 내에서 프린트 val찍으면 20 this.val 찍으면 10 / 정적변수랑은 뭐 정적변수는 클래스명.정적변수명 하면되니까
        사람 김원빈 = new 김원빈  100번 호출해서 김원빈1~김원빈100이 있더라도 김원빈의 멤버메소드 public void 먹다();
        메소드는 힙에 100개 생성안된디 스태틱영역에 클래스랑 같이 김원빈클래스에 먹다(사람 this) 이렇게 메모리아낀디 JVM 자체적으로
    9) super
        상위클래스바라보는 키워드정도로 넘어가자 다만 super.super.method() 이런 귀여운상상은 접어두자 당연히 안되니까

3. 객체지향설계의 5원칙 - SOLID
    1) SRP - Single Responsibility Principle (단일 책임 원칙)
        ==> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
        BeforeSRP / AfterSRP 예제의 강아지클래스를 추상클래스로 빼고 수컷강아지 암컷강아지로 구현

    2) OCP - Open Closed Principle           (개방 폐쇄 원칙)
        ==> 소프트웨어 엔터티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려있어야 하지만 변경에 대해서는 닫혀있어야 한다.
        ==> 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야한다.
        JDBC처럼 오라클 MySQL 변화가 있어도 자바애플리케이션에는 변화가 없는 것 또는 OS를 가리지않고 소스를 개발하는 개발자의 JVM
        BeforeOCP / AfterOCP 예제처럼 강아지가 해변산책, 공원산책 메소드가 있었지만 강변산책에 대한  확장도 열어뒀다.

    3) LSP - Liskov Substitution Principle   (리스코프 치환 원칙)
        ==> 서브타입은 언제나 자신의 기반타입(BASE TYPE)으로 교체할 수 있어야 한다.
        ==> 하위클래스(서브클래스) is a kind of 상위클래스(슈퍼클래스) - 하위 분류는 상위 분류의 한 종류다.
        ==> 구현클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
        /* 전형적인 리스코프치환원칙을 위배하는 계층도/조직도 개념의 상속 */
        class Father
        class Daughter extends Father
            ==> Father amy = new Daughter();   ==>딸이 아버지로서의 역할까지 할 수 있는 뭔가 이상한 구조
            ==> 하위클래스의 인스턴스는 상위 객체 참조변수에 대힝ㅂ해 상위클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

    4) ISP - Interface Segregation Principle (인터페이스 분리 원칙)
        ==> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
        ==> 하나 인터페이스가 하나의 동작만을 하도록 인터페이스가 분리되어야 한다. 쉽게말해 인터페잇으안에 멤버(메소드)를 하나씩 두자 뭐 그런 말(?)

    5) DIP - Dependency Inversion Principle  (의존 역전 원칙)
        ==> 자신보다 변하기 쉬운 것에 의존하지 마라.
        ==> OCP의 결과물을 의존한다는 느낌(?) 더 추상화된클래스일수록 인터페이스일수록 상위클래스일수록 변하지 않을 가능성이 높기때문에 그것을 의존하자
            그런걸 만드는건 OCP인거




    
   
